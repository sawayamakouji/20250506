はい、承知いたしました。提供されたHTMLとJavaScriptのコードについて、少しずつ丁寧に解説します。このコードは、発注データを読み込み、数量を調整し、それらの商品を「パケット」と呼ばれるグループにドラッグ＆ドロップで配分するワークフローを実現するウェブアプリケーションです。UIはサイバーパンク風にデザインされています。

---

### 1. HTML構造の概要

まず、HTMLファイルの全体的な構造を見ていきましょう。

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>発注・配分ワークフロー (金額合計表示) - CYBERPUNK EDITION v3</title>
  <!-- ライブラリCSSの読み込み -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/datatables.net-dt@1.13.6/css/jquery.dataTables.min.css" rel="stylesheet"/>
  <link href="https://cdn.datatables.net/fixedheader/3.4.0/css/fixedHeader.dataTables.min.css" rel="stylesheet"/>
  <!-- Google Fonts (サイバーパンク風フォント) -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <!-- カスタムCSS -->
  <style>
    /* ... (サイバーパンク風のスタイル定義) ... */
  </style>
</head>
<body>
  <h1>発注・配分ワークフロー (金額合計表示)</h1>

  <!-- ファイル入力 -->
  <input type="file" id="file-input" accept=".csv,.xlsx,.xls" class="form-control mb-3" multiple/>

  <!-- タブナビゲーション (ステップ1, ステップ2) -->
  <ul class="nav nav-tabs" id="workflowTabs">
    <li class="nav-item"><a class="nav-link active" data-bs-toggle="tab" href="#step1">ステップ1: 発注数量入力</a></li>
    <li class="nav-item"><a class="nav-link" data-bs-toggle="tab" href="#step2">ステップ2: パケット配分</a></li>
  </ul>

  <!-- タブコンテンツ -->
  <div class="tab-content step-content">
    <!-- ステップ1: 発注数量入力 -->
    <div class="tab-pane fade show active" id="step1">
      <!-- 店舗選択と操作ボタン -->
      <div class="table-controls-top">
        <div>
          対象店舗:
          <select id="store-select" class="form-select d-inline-block" style="width:auto;"></select>
        </div>
        <div>
          <button id="download-order-list-csv" class="btn btn-info btn-sm me-2">全発注リストダウンロード(CSV)</button>
          <button id="to-step2" class="btn btn-primary">次へ</button>
        </div>
      </div>
      <!-- 発注テーブル -->
      <table id="order-table" class="display" style="width:100%">
        <!-- テーブルヘッダー -->
        <thead> ... </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- ステップ2: パケット配分 -->
    <div class="tab-pane fade" id="step2">
      <!-- 操作ボタン (パケット追加、構成読込/保存、CSVダウンロード) -->
      <div class="d-flex justify-content-between align-items-center"> ... </div>
      <!-- ドラッグ＆ドロップエリア -->
      <div class="row mt-3">
        <div class="col-3"><h6>商品リスト</h6><div id="allocation-list" class="drag-drop-list"></div></div>
        <div class="col-9"><div class="packet-container" id="packets"></div></div>
      </div>
    </div>
  </div>

  <!-- JavaScriptライブラリの読み込み -->
  <script src="https://code.jquery.com/jquery-3.7.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/datatables.net@1.13.6/js/jquery.dataTables.min.js"></script>
  <script src="https://cdn.datatables.net/fixedheader/3.4.0/js/dataTables.fixedHeader.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/plugins/SortableMultiDrag.min.js"></script>

  <!-- メインのJavaScriptコード -->
  <script>
    /* ... (アプリケーションのロジック) ... */
  </script>
</body>
</html>
```

**解説**:

*   **`<head>`**:
    *   基本的なHTML設定（文字コード、タイトル）。
    *   外部CSSライブラリを読み込んでいます。
        *   `Bootstrap`: レスポンシブデザインや基本的なUIコンポーネント（ボタン、タブなど）を提供します。
        *   `DataTables`: 高機能なテーブル表示（ソート、フィルタリング、ページネーションなど）を提供します。
        *   `FixedHeader`: DataTablesの拡張で、スクロール時にテーブルヘッダーを固定します。
    *   Google Fontsからサイバーパンク風のフォント (`Orbitron`, `Share Tech Mono`) を読み込んでいます。
    *   `<style>` タグ内に、このページ専用のCSS（サイバーパンク風の見た目）が記述されています。
*   **`<body>`**:
    *   `<h1>`: アプリケーションのタイトルです。
    *   `<input type="file" id="file-input" ... multiple>`: ユーザーがCSVやExcelファイルを選択するための入力欄です。`multiple`属性により、複数のファイルを同時に選択できます。
    *   `<ul class="nav nav-tabs" id="workflowTabs">`: Bootstrapのタブ機能を使って、2つのステップ（「発注数量入力」と「パケット配分」）を切り替えるナビゲーションを作成しています。
    *   `<div class="tab-content step-content">`: 各タブの内容が表示されるエリアです。
        *   **`#step1` (発注数量入力タブ)**:
            *   `<select id="store-select">`: 読み込んだデータから抽出された「対象店舗」を選択するドロップダウンリストです。
            *   `<button id="download-order-list-csv">`: 現在表示されている発注リストをCSV形式でダウンロードするボタンです。
            *   `<button id="to-step2">`: ステップ2（パケット配分）へ進むボタンです。
            *   `<table id="order-table">`: 読み込んだ発注データが表形式で表示されます。DataTablesライブラリによって高機能なテーブルになります。各行には発注数量を入力する欄があります。
        *   **`#step2` (パケット配分タブ)**:
            *   上部には操作ボタン群があります（パケット追加、構成読込/保存、CSVダウンロード）。
            *   `<div id="allocation-list">`: ステップ1で発注数量が入力された商品がリスト表示されます。ここから商品をドラッグしてパケットに移動します。
            *   `<div id="packets">`: 作成されたパケットが表示されるコンテナです。各パケットは商品をドロップできるエリア（ドロップゾーン）を持ちます。
    *   **`<script>` (JavaScriptライブラリ)**:
        *   `jQuery`: DOM操作やイベント処理を容易にするライブラリです。多くの他のライブラリが依存しています。
        *   `Bootstrap Bundle`: BootstrapのJavaScript機能（タブ切り替えなど）を提供します。
        *   `PapaParse`: CSVファイルをパース（解析）するためのライブラリです。
        *   `XLSX`: Excelファイル (xlsx, xls) をパースするためのライブラリです。
        *   `DataTables` と `FixedHeader`: テーブル表示とヘッダー固定機能のJavaScript部分です。
        *   `SortableJS` と `SortableMultiDrag`: ドラッグ＆ドロップ機能をリストや要素間で実現するためのライブラリです。MultiDragプラグインで複数アイテムの同時ドラッグも可能です。
    *   **`<script>` (メインのJavaScriptコード)**: このアプリケーションの主要な動作ロジックが記述されています。これについては後ほど詳しく解説します。

---

### 2. JavaScript - 初期設定とグローバル変数

HTMLの最後に記述されている`<script>`タグ内のJavaScriptコードの冒頭部分です。

```javascript
    if (typeof Sortable !== 'undefined' && typeof Sortable.MultiDrag === 'function') {
        Sortable.mount(new Sortable.MultiDrag());
    }
    const detailKeys = ['取得ファイル名', '伝票日付','チラシ日','売価開始日','売価終了日','重要度','部門','JAN','メーカー名','商品名','規格','発注単位','原価','本体売価','総額売価','税率','値入率','備考'];
    let dataRows = [], storeCols = [], orderTable;
    let allocationItems = []; // Array of item objects in the source list
    let packets = []; // Array of packet objects: { name: string, items: [] }
    const localStorageKey = 'workflowPacketNamesConfigCyber_v3'; // Key for packet names only
    
    initializePacketsFromStorage();
```

**解説**:

*   `Sortable.mount(new Sortable.MultiDrag());`:
    *   `SortableJS` ライブラリの `MultiDrag` プラグインを有効化しています。これにより、ステップ2の商品リストやパケット間で、複数のアイテムを一度に選択してドラッグ＆ドロップできるようになります。
    *   `if`文で `Sortable` と `Sortable.MultiDrag` が正しく読み込まれているかを確認してから実行しています（本番コードではコメントアウトされていますが、開発時には役立つチェックです）。
*   `const detailKeys = [...]`:
    *   ステップ1のテーブルで表示する列のヘッダー名（「取得ファイル名」から「備考」まで）を定義した配列です。この配列は、ファイルから読み込んだデータのどの列を表示するか、またCSVエクスポート時のヘッダーとして使用されます。
*   `let dataRows = [], storeCols = [], orderTable;`:
    *   `dataRows`: ファイルから読み込まれた生データ（行オブジェクトの配列）を格納します。
    *   `storeCols`: ファイルのヘッダーから `detailKeys` に含まれない列名を抽出し、「対象店舗」として扱います。
    *   `orderTable`: DataTablesのインスタンスを格納する変数です。後ほど初期化されます。
*   `let allocationItems = [];`:
    *   ステップ2の商品リスト（左側）に表示されるアイテムのデータを格納する配列です。各要素は商品オブジェクト `{id, name, qty, price, ...その他情報}` となります。
*   `let packets = [];`:
    *   ステップ2のパケット（右側）のデータを格納する配列です。各要素はパケットオブジェクト `{ name: "パケット名", items: [商品オブジェクト1, 商品オブジェクト2, ...] }` となります。
*   `const localStorageKey = 'workflowPacketNamesConfigCyber_v3';`:
    *   ブラウザのローカルストレージにパケット構成（パケットの名前と数）を保存・読み込みする際に使用するキー（識別子）です。
*   `initializePacketsFromStorage();`:
    *   ページ読み込み時にこの関数を呼び出し、ローカルストレージに保存されているパケット構成があればそれを読み込んで `packets` 配列を初期化します。なければデフォルトのパケット構成（パケットA, B, C）で初期化します。この関数の詳細は後述します。

---

### 3. JavaScript - DOM Ready (`$(document).ready(...)`)

このブロック内のコードは、HTMLドキュメントの全ての要素が読み込まれ、操作可能になった後に実行されます。イベントリスナーの設定や、DOM要素に依存する初期化処理などがここで行われます。

```javascript
    $(document).ready(function() {
        // DataTablesの初期化
        orderTable = $('#order-table').DataTable({
            columns: detailKeys.map(() => ({})).concat([{}, {}]), // 列定義
            dom: '<"row"<"col-sm-12 col-md-6"l><"col-sm-12 col-md-6"f>>rt<"row"<"col-sm-12 col-md-5"i><"col-sm-12 col-md-7"p>>', // 要素配置
            fixedHeader: true, // ヘッダー固定有効
            language: { /* 日本語化設定 ... */ }
        });
        
        // DataTables初期化完了時のイベント (init.dt)
        orderTable.on('init.dt', function() {
            // テーブル上部にもページネーションを複製する処理 ...
        });
        
        // DataTables描画完了時のイベント (draw.dt)
        orderTable.on('draw.dt', function () {
            // テーブル上部のページネーションを同期する処理 ...
        });

        // Bootstrapタブ切り替え時のイベント
        $('a[data-bs-toggle="tab"]').on('shown.bs.tab', function (e) {
            // FixedHeaderの調整、ステップ2のリスト再描画など ...
        });

        // --- ここから各種ボタンや入力要素のイベントリスナー設定 ---
        // ... (後述)
    });
```

**解説**:

*   **DataTables初期化**:
    *   `orderTable = $('#order-table').DataTable({...});`: HTMLのテーブル要素 (`id="order-table"`) をDataTablesとして初期化しています。
    *   `columns: detailKeys.map(() => ({})).concat([{}, {}])`:
        *   `detailKeys` 配列の要素数分の列と、追加で2列（提案数量、発注数量）をテーブルに定義します。各 `{}` はデフォルト設定の列を表します。
    *   `dom: '...'`: DataTablesのコントロール要素（件数変更ドロップダウン`l`、検索フィルタ`f`、テーブル本体`t`、情報表示`i`、ページネーション`p`、処理中表示`r`）のHTML内での配置を指定します。Bootstrap 5のグリッドシステム (`row`, `col-sm-12 col-md-6`など) を使ってレイアウトしています。
    *   `fixedHeader: true`: スクロール時にテーブルヘッダーが画面上部に固定されるようにします。
    *   `language: {...}`: DataTablesの表示文言を日本語に設定しています。
*   **DataTablesイベントリスナー (`init.dt`, `draw.dt`)**:
    *   `init.dt`: DataTablesが最初に初期化された後に一度だけ発生します。ここでは、テーブル下部にある標準のページネーションコントロールを複製し、テーブル上部（検索フィルターの隣など）にも表示する処理を行っています。これにより、ユーザーはテーブルの上下どちらでもページ移動ができるようになります。
    *   `draw.dt`: テーブルが再描画されるたび（ソート、フィルタリング、ページ移動時など）に発生します。ここでは、上部に複製したページネーションが下部のものと同期するように、再複製しています。
*   **Bootstrapタブ切り替え時イベント (`$('a[data-bs-toggle="tab"]').on('shown.bs.tab', ...`)**:
    *   Bootstrapのタブが表示された直後に発生するイベントです。
    *   `targetTab`: 表示されたタブのID (`#step1` または `#step2`) を取得します。
    *   FixedHeaderの調整: ステップ1のタブが表示されているときはFixedHeaderを有効にし、カラム幅を再調整します。ステップ2のタブではFixedHeaderを無効にします（ステップ2には大きなテーブルがないため）。
    *   `$($.fn.dataTable.tables(true)).DataTable().columns.adjust();`: 表示されている全てのDataTableのカラム幅を再計算して調整します。タブ切り替えでレイアウトが変わった場合に特に重要です。
    *   ステップ2表示時のリスト再描画: ステップ2に切り替わった際に、商品リスト (`allocationItems`) とパケットリスト (`packets`) の表示を最新の状態に更新します。これは、ステップ1でデータが変更された可能性があるためです。

この `$(document).ready()` ブロック内には、さらに多くのイベントリスナー（ボタンクリックやファイル選択など）が定義されています。それらは次のセクションで個別に見ていきます。

---
### 4. JavaScript - イベントリスナーの詳細

`$(document).ready()` の中で定義されている主要なイベントリスナーについて解説します。

**4.1. 全発注リストダウンロード (CSV)**

```javascript
        $('#download-order-list-csv').off('click').on('click', function() {
            if (!orderTable || !$('#store-select').val()) {
                alert('まず店舗を選択し、データを表示してください。'); return;
            }
            let csvContent = "\uFEFF"; // BOM for UTF-8 Excel compatibility
            const csvHeader = [...detailKeys, "提案数量", "発注数量"];
            csvContent += csvHeader.map(h => `"${h.replace(/"/g, '""')}"`).join(",") + "\r\n";
            
            // DataTables API を使って表示されている (フィルタリングされた) 行のみを対象
            orderTable.rows({ search: 'applied' }).nodes().to$().each(function() {
                const $row = $(this); const rowData = [];
                $row.find('td').each(function(index, cell) {
                    if (index < csvHeader.length - 1) { // detailKeys と 提案数量
                        rowData.push(`"${$(cell).text().trim().replace(/"/g, '""')}"`);
                    } else { // 発注数量 (input要素の値)
                        const qtyInputVal = $(cell).find('input.qty-input').val();
                        rowData.push(qtyInputVal !== undefined ? `"${String(qtyInputVal).replace(/"/g, '""')}"` : '""');
                    }
                });
                csvContent += rowData.join(",") + "\r\n";
            });
            
            const selectedStore = $('#store-select option:selected').text() || "全店舗";
            const fileName = `発注リスト_${selectedStore.replace(/\s/g, '_')}_${new Date().toISOString().slice(0,10)}.csv`;
            // CSVダウンロード処理 (Blob, URL.createObjectURL, aタグクリック)
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob); const link = document.createElement("a");
            link.setAttribute("href", url); link.setAttribute("download", fileName);
            document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
        });
```

*   **トリガー**: 「全発注リストダウンロード(CSV)」ボタン (`id="download-order-list-csv"`) のクリック。
*   **処理**:
    1.  店舗が選択されているか、テーブルデータが存在するかをチェック。
    2.  CSV文字列の開始 (`csvContent`) にBOM (`\uFEFF`) を追加します。これはExcelでUTF-8のCSVを開いた際の文字化けを防ぐためです。
    3.  CSVヘッダー行を作成します (`detailKeys` に "提案数量" と "発注数量" を加えたもの)。各ヘッダー名はダブルクォートで囲み、内部のダブルクォートは二重にします（CSVのエスケープ処理）。
    4.  `orderTable.rows({ search: 'applied' }).nodes().to$().each(...)`: DataTablesのAPIを使用し、**現在フィルタリングされて表示されている行のみ**を対象にループ処理します。
        *   各行の各セルのテキストを取得します。
        *   最後の「発注数量」列は `input` 要素なので、その `value` を取得します。
        *   取得したデータをCSV形式（カンマ区切り、ダブルクォート囲み）で行に追加します。
    5.  選択されている店舗名と現在の日付からファイル名を生成します。
    6.  生成されたCSV文字列を `Blob` オブジェクトに変換します。
    7.  `URL.createObjectURL()` でBlobへのURLを生成し、非表示の `<a>` タグを作成して `download` 属性と `href` 属性を設定し、プログラム的にクリックすることでダウンロードを開始させます。
    8.  後処理として、作成したURLと `<a>` タグを解放・削除します。

**4.2. ファイル入力 (`#file-input`)**

```javascript
        $('#file-input').off('change').on('change', function(e) {
          const files = e.target.files; // 選択されたファイルリスト
          if (!files || files.length === 0) { return; } // ファイルがなければ何もしない

          // 各ファイルを非同期で処理するためのPromiseの配列を作成
          const filePromises = Array.from(files).map(file => {
            return new Promise((resolve, reject) => {
              const reader = new FileReader(); // ファイル内容を読み込むためのオブジェクト
              reader.onload = ev => { // ファイル読み込み完了時の処理
                try {
                  let parsedFileContent = [];
                  // 有効なデータ行か判定するためのキー (これらのうち少なくとも一つが空でないこと)
                  const keysToNotEmpty = ['JAN', 'メーカー名', '商品名', '規格', '発注単位', '原価', '本体売価', '総額売価'];
                  
                  if (file.name.endsWith('.csv')) { // CSVファイルの場合
                    Papa.parse(ev.target.result, { // PapaParseでCSVをパース
                      header: true, // 1行目をヘッダーとして扱う
                      skipEmptyLines: true, // 空行をスキップ
                      dynamicTyping: true, // 数値や真偽値を自動で型変換
                      complete: res => { // パース完了時
                        if (res.data && res.data.length > 0 && typeof res.data[0] === 'object' && res.data[0] !== null) {
                          // 各行に '取得ファイル名' を追加し、有効な行のみフィルタリング
                          parsedFileContent = res.data.map(row => ({ ...row, '取得ファイル名': file.name }))
                            .filter(obj => keysToNotEmpty.some(key => obj[key] != null && String(obj[key]).trim() !== ''));
                        }
                        resolve(parsedFileContent); // パース結果を解決
                      },
                      error: (err) => { console.error("CSV Parse Error for " + file.name + ":", err); resolve([]); } // エラー時は空配列
                    });
                  } else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) { // Excelファイルの場合
                    const wb = XLSX.read(ev.target.result, { type: 'binary' }); // XLSX.jsでExcelを読み込み
                    const targetSheetName = "新データ入力"; 
                    let ws; // ワークシート
                    // 特定のシート名を探す、なければ最初のシートを使用
                    if (wb.SheetNames.includes(targetSheetName)) { ws = wb.Sheets[targetSheetName]; }
                    else if (wb.SheetNames.length > 0) { ws = wb.Sheets[wb.SheetNames[0]]; console.warn(`Sheet "${targetSheetName}" not found in ${file.name}, using first sheet "${wb.SheetNames[0]}"`);}
                    else { resolve([]); return; } // シートがなければ空

                    // ヘッダー行を特定するロジック (複数の候補行をチェック)
                    const rowsAsArrays = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '', raw: false });
                    let headerRowIndex = -1; let actualHeaders = [];
                    const headerCandidateIndices = [5, 6, 7, 0, 1, 2, 3, 4]; // ヘッダー行の候補インデックス
                    let bestMatchCount = 0;
                    for (const idx of headerCandidateIndices) {
                        if (idx < rowsAsArrays.length) {
                            const rowCells = (rowsAsArrays[idx] || []).map(cell => String(cell || '').trim());
                            let matchCount = 0;
                            const detailKeysLower = detailKeys.map(k => k.toLowerCase());
                            rowCells.forEach(rc => { if (detailKeysLower.includes(rc.toLowerCase())) matchCount++; });
                            // detailKeysと3つ以上一致する行をヘッダーとみなす
                            if (matchCount > bestMatchCount && matchCount >= 3) {
                                bestMatchCount = matchCount; headerRowIndex = idx; actualHeaders = rowCells;
                            }
                        }
                    }
                    // 見つからなければ最初の行をヘッダーとみなす (フォールバック)
                     if (headerRowIndex === -1 && rowsAsArrays.length > 0) {
                        headerRowIndex = 0; actualHeaders = (rowsAsArrays[0] || []).map(cell => String(cell || '').trim());
                    }
                    if (headerRowIndex === -1) { resolve([]); return; } // ヘッダーが見つからなければ空

                    // ヘッダー行以降のデータをオブジェクト配列に変換
                    const dataRowsOnly = rowsAsArrays.slice(headerRowIndex + 1);
                    parsedFileContent = dataRowsOnly.map(rowArray => {
                      const obj = { '取得ファイル名': file.name };
                      if (Array.isArray(rowArray)) {
                        actualHeaders.forEach((header, index) => {
                          if (header && header.trim() !== "") { obj[header.trim()] = (rowArray[index] !== undefined && rowArray[index] !== null) ? String(rowArray[index]) : ''; }
                        });
                      }
                      return obj;
                    }).filter(obj => { // 有効な行のみフィルタリング
                        return keysToNotEmpty.some(key => obj[key] != null && String(obj[key]).trim() !== '');
                    });
                    resolve(parsedFileContent);
                  } else { resolve([]); } // 未対応形式
                } catch (error) { console.error("File processing error for " + file.name + ":", error); reject(error); } // エラー時
              };
              reader.onerror = err => { console.error("FileReader error for " + file.name + ":", err); reject(err); };
              // ファイル種別に応じて読み込み方法を決定
              if (file.name.endsWith('.csv')) { reader.readAsText(file); } // CSVはテキストとして
              else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) { reader.readAsBinaryString(file); } // Excelはバイナリとして
              else { alert("未対応形式: " + file.name); resolve([]); }
            });
          });

          // 全てのファイルの読み込みとパースが終わったら実行
          Promise.all(filePromises).then(results => {
            // resultsは各ファイルのパース結果(オブジェクト配列)の配列
            const allParsedData = results.reduce((acc, data) => acc.concat(data), []); // 全てのデータを結合
            if (allParsedData.length === 0 && files.length > 0) { alert("読み込みに成功しましたが、有効なデータが見つかりませんでした。"); }
            handle(allParsedData); // 結合したデータで後続処理 (handle関数の詳細は後述)
          }).catch((err) => { console.error("Overall file processing error:", err); alert("一部または全てのファイルの処理中にエラーが発生しました。"); handle([]); });
          $(this).val(''); // ファイル入力欄をリセット (同じファイルを再度選択できるようにするため)
        });
```

*   **トリガー**: ファイル入力欄 (`id="file-input"`) の内容が変更されたとき（ファイルが選択されたとき）。
*   **処理**:
    1.  選択されたファイル群 (`files`) を取得します。
    2.  `Array.from(files).map(...)`: 各ファイルに対して非同期処理を行うための `Promise` を作成します。
        *   `FileReader` を使用してファイル内容を読み込みます。
        *   ファイル拡張子に応じて処理を分岐します。
            *   **.csv**: `PapaParse` ライブラリでCSVデータをパースします。`header: true` で1行目をキーとし、各行をオブジェクトに変換します。各行オブジェクトに `'取得ファイル名': file.name` を追加し、`keysToNotEmpty` で定義された必須キーのいずれかが空でない行のみを有効なデータとして残します。
            *   **.xlsx, .xls**: `XLSX.js` ライブラリでExcelデータを読み込みます。
                *   まず "新データ入力" という名前のシートを探し、なければ最初のシートを使用します。
                *   ヘッダー行の特定: 特定の行番号の候補（5,6,7行目、その後0-4行目）をチェックし、`detailKeys` に含まれる項目名が多く存在する行をヘッダー行とみなします。適切なヘッダーが見つからない場合は、最初の行をヘッダーとして扱います。
                *   ヘッダー行以降のデータを、ヘッダー名をキーとするオブジェクトの配列に変換します。ここでも `'取得ファイル名'` を追加し、`keysToNotEmpty` でフィルタリングします。
            *   未対応形式の場合は空の配列を返します。
        *   読み込みやパース中にエラーが発生した場合は、コンソールにエラーを出力し、空の配列を返します。
    3.  `Promise.all(filePromises).then(...)`: 全てのファイルの非同期読み込み・パース処理が完了するのを待ちます。
        *   `results` には各ファイルのパース結果（オブジェクトの配列）が配列として格納されています。
        *   `results.reduce((acc, data) => acc.concat(data), [])`: 全てのファイルのパース結果を一つの大きな配列 `allParsedData` に結合します。
        *   有効なデータがなければアラートを表示します。
        *   `handle(allParsedData)`: 結合されたデータを使って、店舗リストの作成やグローバル変数 `dataRows` の更新などを行う `handle` 関数（後述）を呼び出します。
    4.  `$(this).val('');`: ファイル入力欄の値をクリアします。これにより、同じファイルを再度選択した場合でも `change` イベントが正しく発生するようになります。

**4.3. 対象店舗選択 (`#store-select`)**

```javascript
        $('#store-select').off('change').on('change', function(){
          const store = this.value; // 選択された店舗名
          orderTable.clear(); // DataTablesの内容を一旦クリア
          if(!store || !dataRows || dataRows.length === 0){ orderTable.draw(); return; } // 店舗未選択またはデータなし

          // dataRows (全ファイルから読み込んだデータ) を一行ずつ処理
          dataRows.forEach((r, index) => { 
            if (typeof r !== 'object' || r === null) return; // 無効な行はスキップ
            
            const proposalQtyRaw = r[store]; // 選択された店舗名に対応する列の値を取得 (提案数量)
            // 提案数量が数値として妥当か確認し、そうでなければ0とする
            const proposalQty = (proposalQtyRaw != null && !isNaN(parseFloat(String(proposalQtyRaw).replace(/,/g, '')))) ? parseFloat(String(proposalQtyRaw).replace(/,/g, '')) : 0;
            
            // 本体売価と発注単位を取得 (カンマ除去、数値変換、デフォルト値設定)
            const unitPrice = parseFloat(String(r['本体売価'] || 0).replace(/,/g, '')) || 0; 
            const orderUnit = parseFloat(String(r['発注単位'] || 1).replace(/,/g, '')) || 1;

            // 初期発注数量を計算 (提案数量がマイナスなら0、発注単位で丸め)
            let initialOrderQty = proposalQty < 0 ? 0 : proposalQty;
            if (orderUnit > 0 && initialOrderQty > 0 && initialOrderQty % orderUnit !== 0) initialOrderQty = Math.ceil(initialOrderQty / orderUnit) * orderUnit;
            
            // 発注数量入力用のinput要素HTMLを生成
            const orderQtyInput = `<input type="number" class="form-control qty-input" min="0" step="${orderUnit > 0 ? orderUnit : 1}" value="${initialOrderQty}" data-price="${unitPrice}" data-order-unit="${orderUnit}" data-row-original-index="${index}" />`;
            
            // DataTablesに追加する行データを作成 (detailKeysに対応する値 + 提案数量 + 発注数量input)
            const rowData = detailKeys.map(k => (r[k] !== undefined && r[k] !== null) ? String(r[k]) : '');
            rowData.push(proposalQty, orderQtyInput); 
            orderTable.row.add(rowData); // DataTablesに行を追加
          });
          orderTable.draw(); // DataTablesを再描画
        });
```

*   **トリガー**: 対象店舗ドロップダウン (`id="store-select"`) の選択値が変更されたとき。
*   **処理**:
    1.  選択された店舗名 (`store`) を取得します。
    2.  DataTables (`orderTable`) の表示内容を一旦クリアします。
    3.  店舗が選択されていない、または `dataRows` が空の場合は、何もせずに処理を終了します。
    4.  `dataRows` (ファイルから読み込まれた全てのデータ) を1行ずつ処理します。
        *   各行 (`r`) から、選択された店舗名 (`store`) をキーとして「提案数量」を取得します。数値でない場合は0として扱います。
        *   「本体売価」と「発注単位」も取得し、数値に変換します（カンマが含まれていれば除去）。
        *   初期の「発注数量」を計算します。提案数量を基に、マイナスなら0にし、発注単位で割り切れない場合は切り上げて丸めます。
        *   発注数量を入力するための `<input type="number">` 要素のHTML文字列を生成します。このinput要素には、`data-price` (単価)、`data-order-unit` (発注単位)、`data-row-original-index` (元の `dataRows` でのインデックス) といったカスタムデータ属性も付与されます。
        *   `detailKeys` に基づいて表示するデータを準備し、最後に計算した「提案数量」と生成した「発注数量input要素」を追加して、DataTables用の行データ (`rowData`) を作成します。
        *   `orderTable.row.add(rowData).draw(false)` でDataTablesに1行ずつ追加します。
    5.  最後に `orderTable.draw()` を呼び出し、テーブル全体を再描画して変更を画面に反映させます。

**4.4. 発注数量入力欄の処理**

```javascript
        $(document).off('input change blur', '#order-table tbody .qty-input').on('input change blur', '#order-table tbody .qty-input', function(event) {
            const $input = $(this); // イベントが発生したinput要素
            const orderUnit = parseFloat($input.data('order-unit')) || 1; // data属性から発注単位を取得
            let currentQty = parseFloat($input.val()); // 入力された値を取得し数値に変換

            if (isNaN(currentQty)) { // 数値でない場合
                if (event.type === 'blur' && $input.val().trim() === '') $input.val(0); // blur時かつ空欄なら0をセット
                return; 
            }
            if (currentQty < 0) { currentQty = 0; $input.val(0); } // マイナス値なら0に

            // blur (フォーカスが外れた) または change (値が確定変更された) イベントの場合
            if (event.type === 'blur' || event.type === 'change') {
                if (orderUnit > 0 && currentQty > 0) { // 発注単位があり、数量が0より大きい場合
                    const adj = Math.ceil(currentQty / orderUnit) * orderUnit; // 発注単位で切り上げ
                    if (parseFloat($input.val()) !== adj) $input.val(adj); // 丸めた値と異なれば更新
                } else if (currentQty === 0) { 
                    $input.val(0); // 0なら0を確定
                }
            }
        });
```

*   **トリガー**: ステップ1のテーブル内の発注数量入力欄 (`.qty-input`) で `input` (入力途中)、`change` (値変更確定後)、`blur` (フォーカスが外れた) のいずれかのイベントが発生したとき。
*   **処理**:
    1.  イベントが発生した `input` 要素 (`$input`) と、その `data-order-unit` 属性から発注単位を取得します。
    2.  入力された値 (`$input.val()`) を数値 (`currentQty`) に変換します。
    3.  入力が数値でない場合:
        *   イベントが `blur` で、かつ入力欄が空文字列であれば、値を0に設定します。
        *   それ以外（入力途中など）は何もしません。
    4.  入力値が0未満であれば、0に修正します。
    5.  イベントが `blur` または `change` の場合（つまり、入力が一段落したとき）:
        *   発注単位が設定されており、かつ入力数量が0より大きい場合、入力数量を発注単位の倍数になるように切り上げます。例えば、発注単位が10で入力が12なら20に、入力が8なら10になります。
        *   入力数量が0の場合は、明示的に0を設定します。

**4.5. 「次へ」ボタン (ステップ1 → ステップ2)**

```javascript
        $('#to-step2').off('click').on('click', function(){
          allocationItems = []; // グローバルな商品リストを初期化
          // DataTablesで表示されている (フィルタリングされた) 行を処理
          orderTable.rows({ search: 'applied' }).nodes().to$().each(function(idx) {
            const $row = $(this); const $cells = $row.find('td'); if ($cells.length === 0) return;
            
            // 各セルから情報を取得
            const sourceFileName = $cells.eq(detailKeys.indexOf('取得ファイル名')).text().trim();
            const itemName = $cells.eq(detailKeys.indexOf('商品名')).text().trim();
            const $input = $cells.last().find('input.qty-input'); if ($input.length === 0) return;
            
            const qty = parseFloat($input.val()) || 0; 
            const price = parseFloat($input.data('price')) || 0;
            
            if(qty > 0 && itemName && !isNaN(price)) { // 発注数量があり、商品名があり、価格が数値の場合のみ
                const slipDate = $cells.eq(detailKeys.indexOf('伝票日付')).text().trim();
                // ... (JAN, メーカー名など他の情報も同様に取得) ...
                const grossProfitRate = $cells.eq(detailKeys.indexOf('値入率')).text().trim();
                // allocationItemsに追加するアイテムのユニークIDを生成
                const originalDataIndex = $input.data('row-original-index') !== undefined ? $input.data('row-original-index') : idx;
                const uniqueId = `item_${jan || ('nojancode' + Math.random().toString(36).substr(2, 5))}_${originalDataIndex}_${Date.now()}`;

                // allocationItems配列に商品オブジェクトを追加
                allocationItems.push({ 
                    id: uniqueId, 
                    sourceFileName: sourceFileName, name: itemName, qty: qty, price: price, 
                    slipDate: slipDate, department: department, jan: jan, maker: maker, 
                    standard: standard, grossProfitRate: grossProfitRate 
                });
            }
          });
          // 既存のパケット内のアイテムをクリア (ステップ2移行時にパケットは空にするため)
          packets.forEach(p => p.items = []); 

          renderAllocationList(); // ステップ2の商品リストを再描画 (詳細は後述)
          renderPackets(true);    // ステップ2のパケットを再描画 (詳細は後述)
          new bootstrap.Tab($('#workflowTabs a[href="#step2"]')[0]).show(); // ステップ2のタブを表示
        });
```

*   **トリガー**: 「次へ」ボタン (`id="to-step2"`) のクリック。
*   **処理**:
    1.  グローバル変数 `allocationItems` を空の配列に初期化します。これがステップ2の商品リストの元データになります。
    2.  DataTablesで現在表示されている（フィルタリング結果の）各行についてループ処理します。
        *   各行のセルから、商品名、取得ファイル名、伝票日付、部門、JANコード、メーカー名、規格、値入率などの情報を取得します。
        *   発注数量入力欄から実際の「発注数量 (`qty`)」と「単価 (`price`)」を取得します。
        *   発注数量が0より大きく、商品名が存在し、単価が有効な数値である場合のみ、処理を続けます。
        *   各商品アイテムにユニークな `id` を生成します。このIDは、後のドラッグ＆ドロップ操作でアイテムを識別するために重要です。JANコード、元のデータのインデックス、現在時刻などを組み合わせて作成しています。
        *   取得した全ての情報を含むオブジェクトを作成し、`allocationItems` 配列に追加します。
    3.  `packets.forEach(p => p.items = []);`: 既存の各パケットオブジェクト内の `items` 配列（商品情報）を空にします。これにより、ステップ2に移行する際に、以前のパケット内容はクリアされ、商品リスト (`allocationItems`) から新たに配分し直す形になります。
    4.  `renderAllocationList()`: `allocationItems` 配列の内容に基づいて、ステップ2の左側の商品リストDOMを生成・表示し、SortableJSを適用します（詳細は後述）。
    5.  `renderPackets(true)`: `packets` 配列（名前は維持、アイテムは空）に基づいて、ステップ2の右側のパケット群DOMを生成・表示し、各パケットのドロップゾーンにSortableJSを適用します（詳細は後述）。`true` は強制的に全体を再描画することを意味します。
    6.  `new bootstrap.Tab($('#workflowTabs a[href="#step2"]')[0]).show();`: Bootstrapの機能を使って、ステップ2のタブをアクティブにして表示します。

---
**4.6. パケット追加ボタン (`#add-packet`)**

```javascript
        $('#add-packet').off('click').on('click', function() { 
            const newPacketName = `新規パケット ${packets.length + 1}`; 
            // packets配列に新しいパケットオブジェクト (名前と空のアイテムリスト) を追加
            packets.push({ name: newPacketName, items: [] }); 
            renderPackets(); // パケット表示を更新 (新しいパケットが追加される)
        });
```

*   **トリガー**: 「パケット追加」ボタン (`id="add-packet"`) のクリック。
*   **処理**:
    1.  新しいパケットの名前を生成します（例: "新規パケット 1", "新規パケット 2"...）。
    2.  グローバル変数 `packets` 配列に、新しいパケットオブジェクト `{ name: "生成された名前", items: [] }` を追加します。`items` は最初は空です。
    3.  `renderPackets()`: パケット群の表示を更新します。この関数は `packets` 配列を参照してDOMを構築するため、新しく追加されたパケットも画面に表示されます（詳細は後述）。

**4.7. パケット構成保存ボタン (`#save-packet-config`)**

```javascript
        $('#save-packet-config').off('click').on('click', function(){
          const packetNamesToSave = []; 
          // 現在画面に表示されている各パケットのタイトル(h6要素)から名前を取得
          $('#packets .packet h6').each(function() { 
              packetNamesToSave.push($(this).text().trim()); 
          });
          // グローバルなpackets配列内の各パケットオブジェクトの名前をDOM上の名前に更新
          packets.forEach((packet, index) => {
              if (packetNamesToSave[index]) { // DOM上に同インデックスのパケット名があれば
                  packet.name = packetNamesToSave[index];
              }
          });
          // 保存する設定オブジェクトを作成 (パケット名の配列のみ)
          const configToSave = { packetNames: packets.map(p => p.name) };
          const jsonString = JSON.stringify(configToSave, null, 2); // JSON文字列に変換 (整形)
          
          localStorage.setItem(localStorageKey, jsonString); // ローカルストレージに保存
          
          // JSONファイルとしてもダウンロード
          const blob = new Blob([jsonString], { type: 'application/json' }); 
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a'); 
          link.href = url; 
          link.download = 'packet_names_config.json'; // ダウンロードファイル名
          document.body.appendChild(link); 
          link.click(); // プログラム的にクリックしてダウンロード
          document.body.removeChild(link); 
          URL.revokeObjectURL(url);
          alert('パケット構成（名前のみ）をローカルストレージとファイルに保存しました。');
        });
```

*   **トリガー**: 「構成保存」ボタン (`id="save-packet-config"`) のクリック。
*   **処理**:
    1.  `packetNamesToSave` 配列を初期化します。
    2.  画面に表示されている各パケットの `<h6>` 要素（パケット名が表示されている部分）から、現在のテキスト（パケット名）を取得し、`packetNamesToSave` 配列に格納します。
    3.  グローバル変数 `packets` 配列内の各パケットオブジェクトの `name` プロパティを、今取得したDOM上の名前に更新します。これにより、ユーザーが画面上で編集したパケット名が `packets` 配列に反映されます。
    4.  保存用の設定オブジェクト `configToSave` を作成します。このオブジェクトは `{ packetNames: ["名前1", "名前2", ...] }` という形式で、パケット名の配列のみを保持します。パケット内のアイテムは保存しません。
    5.  `JSON.stringify(configToSave, null, 2)` を使って、設定オブジェクトを人間が読みやすい形式（インデント付き）のJSON文字列に変換します。
    6.  `localStorage.setItem(localStorageKey, jsonString)`: 生成されたJSON文字列を、定義済みの `localStorageKey` を使ってブラウザのローカルストレージに保存します。これにより、次回ページを開いたときにこの構成を読み込めます。
    7.  同じJSON文字列をファイルとしてもダウンロードさせます。
        *   `Blob` オブジェクトを作成し、`URL.createObjectURL` でダウンロード用URLを生成。
        *   非表示の `<a>` タグを作成し、`download` 属性と `href` を設定してクリックすることで、`packet_names_config.json` という名前でファイルがダウンロードされます。
    8.  保存完了のアラートを表示します。

**4.8. パケット構成読込ボタン (`#load-packet-config` & `#load-packet-config-input`)**

```javascript
        $('#load-packet-config').off('click').on('click', function() { 
            $('#load-packet-config-input').click(); // 非表示のファイル入力要素をクリックさせる
        });
        $('#load-packet-config-input').off('change').on('change', function(e) {
            const file = e.target.files[0]; if (!file) return; 
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const loadedConfig = JSON.parse(event.target.result); // 読み込んだファイル内容をJSONとしてパース
                    // 期待する形式は { packetNames: ["名前1", "名前2", ...] }
                    if (loadedConfig && Array.isArray(loadedConfig.packetNames)) {
                        // グローバルなpackets配列を、読み込んだ名前で再構築 (itemsは空)
                        packets = loadedConfig.packetNames.map(name => ({ name: name, items: [] }));
                        // ローカルストレージにも保存
                        localStorage.setItem(localStorageKey, JSON.stringify({ packetNames: loadedConfig.packetNames }));
                        
                        renderAllocationList(); // 現在の商品リストを再描画 (内容は変わらないはず)
                        renderPackets(true);    // 新しいパケット構成でパケット群を再描画 (アイテムは空)
                        alert('パケット構成（名前のみ）を読み込みました。');
                    } else { 
                        alert('JSONファイルの形式が正しくありません。packetNames配列が必要です。'); 
                    }
                } catch (err) { 
                    alert('パケット構成ファイルの読み込み失敗: ' + err.message); 
                }
            };
            reader.readAsText(file); // ファイルをテキストとして読み込み
            $(this).val(''); // ファイル入力欄をリセット
        });
```

*   **トリガー**:
    *   「構成読込」ボタン (`id="load-packet-config"`) がクリックされると、非表示のファイル入力要素 (`id="load-packet-config-input"`) をプログラム的にクリックします。
    *   非表示のファイル入力要素でファイルが選択されると、その `change` イベントが発生します。
*   **処理 (`load-packet-config-input` の `change` イベント)**:
    1.  選択されたファイルを取得します。
    2.  `FileReader` を使ってファイルの内容をテキストとして読み込みます。
    3.  読み込み完了後、ファイル内容 (`event.target.result`) を `JSON.parse()` でJavaScriptオブジェクトに変換します。
    4.  読み込んだオブジェクト (`loadedConfig`) が、期待する形式 (`{ packetNames: [...] }` で、かつ `packetNames` が配列であること) かどうかを検証します。
    5.  形式が正しければ:
        *   グローバル変数 `packets` 配列を、読み込んだ `packetNames` の配列を元に再構築します。各要素は `{ name: "読み込んだ名前", items: [] }` となり、アイテムリストは空です。
        *   読み込んだパケット名構成をローカルストレージにも保存します。
        *   `renderAllocationList()`: 現在の商品リスト (`allocationItems`) を再描画します。この時点では `allocationItems` の内容は変更されていません。
        *   `renderPackets(true)`: 新しく構築された `packets` 配列（名前のみ更新され、アイテムは空）に基づいて、パケット群の表示を完全に再描画します。
        *   読み込み完了のアラートを表示します。
    6.  形式が不正、またはJSONパースに失敗した場合は、エラーメッセージをアラート表示します。
    7.  ファイル入力欄の値をリセットします。

**4.9. パケット配分結果CSVダウンロードボタン (`#download-csv`)**

```javascript
        $('#download-csv').off('click').on('click', function() { 
            let csvContent = "\uFEFF"; // BOM
            const header = ["取得ファイル名", "パケット名", "伝票日付", "部門", "JAN", "メーカー名", "商品名", "規格", "値入率", "数量", "単価(本体売価)", "合計金額(本体売価)"];
            csvContent += header.map(h => `"${h.replace(/"/g, '""')}"`).join(",") + "\r\n";
            
            // グローバルな `packets` 配列を処理
            packets.forEach(packet => {
                const packetName = (packet.name || "名称未設定パケット").replace(/"/g, '""');
                if (!packet.items || packet.items.length === 0) {
                    // 空のパケットの行をCSVに追加するならここに記述 (現在は何もしない)
                } else {
                    // パケット内の各アイテムを処理
                    packet.items.forEach(item => {
                        const itemTotal = (item.qty || 0) * (item.price || 0);
                        const row = [
                            `"${(item.sourceFileName || '').replace(/"/g, '""')}"`, `"${packetName}"`, 
                            `"${(item.slipDate || '').replace(/"/g, '""')}"`, `"${(item.department || '').replace(/"/g, '""')}"`,
                            `"${(item.jan || '').replace(/"/g, '""')}"`, `"${(item.maker || '').replace(/"/g, '""')}"`,
                            `"${(item.name || '').replace(/"/g, '""')}"`, `"${(item.standard || '').replace(/"/g, '""')}"`,
                            `"${(item.grossProfitRate || '').replace(/"/g, '""')}"`, 
                            item.qty || 0, 
                            item.price || 0, 
                            itemTotal
                        ];
                        csvContent += row.join(",") + "\r\n";
                    });
                }
            });
            // CSVダウンロード処理 (Blob, URL.createObjectURL, aタグクリック)
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }); 
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a"); 
            link.setAttribute("href", url); 
            link.setAttribute("download", "パケット配分結果_詳細.csv");
            document.body.appendChild(link); 
            link.click(); 
            document.body.removeChild(link); 
            URL.revokeObjectURL(url);
        });
```

*   **トリガー**: 「CSVダウンロード」ボタン (`id="download-csv"`) のクリック。
*   **処理**:
    1.  CSV文字列 `csvContent` をBOMで初期化します。
    2.  CSVのヘッダー行を定義し、`csvContent` に追加します。
    3.  グローバル変数 `packets` 配列をループ処理します。各要素は `{ name: "パケット名", items: [商品オブジェクト...] }` というパケットオブジェクトです。
        *   各パケットについて、その名前を取得します。
        *   パケット内の `items` 配列をループ処理します。
            *   各アイテム (`item`) から、取得ファイル名、伝票日付、部門、JAN、メーカー名、商品名、規格、値入率、数量、単価などの情報を取得します。
            *   数量と単価から合計金額を計算します。
            *   これらの情報をCSVの1行として整形し、`csvContent` に追加します。各値はダブルクォートで囲み、エスケープ処理を施します。
    4.  生成された `csvContent` を使って、`#download-order-list-csv` の時と同様の手順でCSVファイルをダウンロードさせます。ファイル名は "パケット配分結果\_詳細.csv" となります。

---
### 5. JavaScript - 主要関数定義

グローバルスコープで定義されている主要なヘルパー関数について解説します。

**5.1. `initializePacketsFromStorage()`**

```javascript
    function initializePacketsFromStorage() {
        const savedPacketConfigJson = localStorage.getItem(localStorageKey); // ローカルストレージから保存された構成を取得
        if (savedPacketConfigJson) { // 保存された構成がある場合
            try {
                const savedConfig = JSON.parse(savedPacketConfigJson); // JSON文字列をオブジェクトにパース
                // 期待する形式は { packetNames: ["名前1", "名前2", ...] }
                if (savedConfig && Array.isArray(savedConfig.packetNames)) {
                    // 保存されたパケット名の配列から、packets配列を {name, items:[]} の形式で再構築
                    packets = savedConfig.packetNames.map(name => ({ name: name, items: [] }));
                } else { 
                    // 形式が不正な場合はデフォルトのパケット構成を使用
                    packets = [{name:'パケットA', items:[]},{name:'パケットB', items:[]},{name:'パケットC', items:[]}]; 
                }
            } catch (e) { // JSONパースエラーの場合
                packets = [{name:'パケットA', items:[]},{name:'パケットB', items:[]},{name:'パケットC', items:[]}]; 
                localStorage.removeItem(localStorageKey); // 不正なデータをローカルストレージから削除
            }
        } else { 
            // 保存された構成がない場合はデフォルトのパケット構成を使用
            packets = [{name:'パケットA', items:[]},{name:'パケットB', items:[]},{name:'パケットC', items:[]}]; 
        }
    }
```

*   **目的**: アプリケーション起動時に、ブラウザのローカルストレージに保存されているパケット構成（パケットの名前と数）を読み込み、グローバル変数 `packets` を初期化します。
*   **処理**:
    1.  `localStorage.getItem(localStorageKey)` で、指定されたキー (`localStorageKey`) を使ってローカルストレージから保存済みの設定文字列（JSON形式のはず）を取得します。
    2.  取得した文字列が存在すれば、`JSON.parse()` でJavaScriptオブジェクトに変換します。
    3.  変換後のオブジェクト (`savedConfig`) が存在し、かつ `packetNames` というプロパティが配列であれば、その `packetNames` 配列の各名前を使って `packets` 配列を初期化します。各パケットは `{ name: "読み込んだ名前", items: [] }` というオブジェクトになり、`items`（商品リスト）は常に空で初期化されます。
    4.  JSON文字列のパースに失敗した場合や、期待する形式でなかった場合は、デフォルトのパケット構成（"パケットA", "パケットB", "パケットC"、それぞれアイテムは空）で `packets` 配列を初期化します。パース失敗時は、ローカルストレージの不正なデータを削除します。
    5.  ローカルストレージに何も保存されていなかった場合も、デフォルトのパケット構成で初期化します。

**5.2. `handle(data)`**

```javascript
    const handle = data => {
        if (!data || data.length === 0) { // 渡されたデータが空、または無効な場合
          dataRows = []; storeCols = []; 
          $('#store-select').empty().append('<option value="">--選択--</option>'); 
          if (orderTable) orderTable.clear().draw(); // テーブルをクリア
          return;
        }
        dataRows = data; // グローバル変数に読み込んだデータを格納
        const allFileKeys = new Set(); // ファイル内の全ての列名(キー)を重複なく収集するためのSet
        
        // dataRowsの各行オブジェクトからキーを抽出し、allFileKeysに追加
        dataRows.forEach(row => { 
            if (typeof row === 'object' && row !== null) {
                Object.keys(row).forEach(key => allFileKeys.add(String(key).trim())); 
            }
        });
        
        storeCols = []; // 店舗カラムリストを初期化
        const detailKeysLower = detailKeys.map(dk => dk.toLowerCase()); // detailKeysを小文字に変換 (比較用)
        
        // allFileKeysから、detailKeysに含まれないキーを店舗カラムとして抽出
        allFileKeys.forEach(key => { 
            if (!detailKeysLower.includes(key.toLowerCase()) && key !== "") { // detailKeysになく、空文字列でもない
                storeCols.push(key); 
            }
        });
        
        // 店舗選択ドロップダウンを再構築
        const $storeSelect = $('#store-select').empty().append('<option value="">--選択--</option>');
        if (storeCols.length > 0) {
            storeCols.sort().forEach(s => $storeSelect.append(`<option value="${s}">${s}</option>`)); // 店舗名をソートして追加
        }
        
        if (orderTable) orderTable.clear().draw(); // DataTablesをクリアして再描画 (内容は空)
      };
```

*   **目的**: ファイル入力処理 (`#file-input` の `change` イベント内) でパースされたデータを受け取り、アプリケーションの内部状態（`dataRows`, `storeCols`）を更新し、関連するUI（店舗選択ドロップダウン）を再構築します。
*   **処理**:
    1.  引数で渡されたデータ (`data`) が有効か（空でないかなど）をチェックします。無効なら内部状態をリセットし、テーブルをクリアして終了します。
    2.  有効なデータであれば、グローバル変数 `dataRows` にそのデータを格納します。
    3.  `allFileKeys` という `Set` を用意し、`dataRows` 内の全ての行オブジェクトが持つキー（列名）を重複なく収集します。
    4.  グローバル変数 `storeCols`（店舗名のリスト）を初期化します。
    5.  `detailKeys`（固定の列名リスト）を小文字に変換したものを用意します（大文字・小文字を区別しない比較のため）。
    6.  `allFileKeys` をループし、各キーが `detailKeysLower` に含まれておらず、かつ空文字列でもない場合、それを店舗カラム名とみなし `storeCols` に追加します。
    7.  店舗選択ドロップダウン (`id="store-select"`) の中身を一旦空にし、最初に「--選択--」オプションを追加します。
    8.  抽出された `storeCols` があれば、それらをソートし、ドロップダウンのオプションとして追加します。
    9.  DataTables (`orderTable`) の内容をクリアして再描画します（この時点ではテーブルは空になります。店舗を選択すると内容が表示されます）。

**5.3. `renderAllocationList()`**

```javascript
    function renderAllocationList() {
        const listElement = document.getElementById('allocation-list'); // 商品リストのDOM要素
        $(listElement).empty(); // 中身を一旦空にする
        
        // グローバルな allocationItems 配列を元にリストアイテムを生成
        allocationItems.forEach(item => {
            $(listElement).append(
                // 各アイテムの情報を data-* 属性として埋め込み、表示テキストを作成
                `<div class="item" 
                      data-id="${item.id}"
                      data-source-file-name="${item.sourceFileName || ''}" 
                      data-name="${item.name || ''}" // 商品名をdata属性にも保持
                      data-qty="${item.qty}" 
                      data-price="${item.price}" 
                      data-slip-date="${item.slipDate || ''}" 
                      data-department="${item.department || ''}" 
                      data-jan="${item.jan || ''}" 
                      data-maker="${item.maker || ''}" 
                      data-standard="${item.standard || ''}" 
                      data-gross-profit-rate="${item.grossProfitRate || ''}" 
                 >${item.name} (${item.qty})</div>`
            );
        });

        // SortableJSのインスタンスがあれば破棄し、再生成
        if (Sortable.get(listElement)) { Sortable.get(listElement).destroy(); }
        Sortable.create(listElement, {
            group: 'shared', // 'shared'グループ内の他のリストとアイテムを移動可能にする
            multiDrag: true, // 複数アイテム同時ドラッグ有効
            selectedClass: 'selected', // 選択されたアイテムに付与するCSSクラス
            animation: 150, // アニメーション速度 (ms)
            onEnd: handleSortableEndEvent // ドラッグ終了時の処理を行う関数 (後述)
        });
    }
```

*   **目的**: ステップ2の左側にある「商品リスト」の表示を、グローバル変数 `allocationItems` の内容に基づいて更新し、SortableJS（ドラッグ＆ドロップ機能）を適用します。
*   **処理**:
    1.  商品リストのDOM要素 (`id="allocation-list"`) を取得し、その中身を `$(listElement).empty()` で一旦空にします。
    2.  `allocationItems` 配列の各商品オブジェクト (`item`) についてループ処理します。
        *   各 `item` の情報（ID, ファイル名, 商品名, 数量, 単価, 伝票日付など）を `data-*` カスタム属性として持つ `<div>` 要素（クラス名 `item`）を生成します。
        *   表示テキストは「商品名 (数量)」となります。
        *   生成した `<div>` 要素を商品リストDOMに追加します。
    3.  商品リストDOM要素に既にSortableJSのインスタンスが適用されていれば、`Sortable.get(listElement).destroy()` で一旦破棄します。
    4.  `Sortable.create(listElement, {...})` で、商品リストDOM要素に新しくSortableJSを適用します。
        *   `group: 'shared'`: このリストは `'shared'` という名前のグループに属します。同じグループ名を持つ他のSortableJSリスト（パケットのドロップゾーン）との間でアイテムの移動が可能になります。
        *   `multiDrag: true`: 複数のアイテムを同時に選択してドラッグできるようにします。
        *   `selectedClass: 'selected'`: 選択されたアイテムに付与されるCSSクラス名です。
        *   `animation: 150`: ドラッグ＆ドロップ時のアニメーションの速さ（ミリ秒）です。
        *   `onEnd: handleSortableEndEvent`: アイテムのドラッグ＆ドロップ操作が完了したときに呼び出されるコールバック関数です。この関数 (`handleSortableEndEvent`) が、`allocationItems` 配列や `packets` 配列のデータを実際に更新する重要な役割を担います（詳細は後述）。

**5.4. `renderPackets(forceFullRender)`**

```javascript
    function renderPackets(forceFullRender = false) {
      const container = $('#packets'); // パケットを表示するコンテナDOM要素
      if (forceFullRender) { // 強制的に全再描画する場合
          // 全てのパケット内のdropzoneからSortableJSインスタンスを破棄
          container.find('.dropzone').each(function() { 
              if (Sortable.get(this)) { Sortable.get(this).destroy(); } 
          });
          container.empty(); // コンテナの中身を全て削除
      }

      // グローバルなpackets配列を元にパケットをレンダリング
      packets.forEach((packetData, packetIndex) => {
        let packetDiv = container.find(`.packet[data-packet-idx="${packetIndex}"]`); // 既存のパケットdivを探す
        
        // 既存のパケットdivがない、または強制再描画の場合に新しく作成
        if (!packetDiv.length || forceFullRender) {
           if (packetDiv.length && forceFullRender) packetDiv.remove(); // 強制再描画なら既存を削除
           packetDiv = $( // 新しいパケットのHTMLを生成
               `<div class="packet" data-packet-idx="${packetIndex}">
                   <h6 contenteditable data-idx="${packetIndex}">${packetData.name}</h6>
                   <div class="dropzone" data-idx="${packetIndex}" id="dropzone-packet-${packetIndex}"></div>
                   <div class="sum">合計: 0 円</div>
                </div>`
           );
           container.append(packetDiv); // コンテナに追加
           // パケット名(h6)を編集可能にし、編集後の処理を設定
           packetDiv.find('h6').on('blur', e => { // フォーカスが外れた時
            const newName = e.target.textContent.trim(); 
            const idx = parseInt(e.target.dataset.idx, 10);
            if (newName && packets[idx]) { // 新しい名前があり、対応するパケットデータが存在すれば
                packets[idx].name = newName; // packets配列の名前を更新
            } else if (packets[idx]) { // 新しい名前が空なら元の名前に戻す
                e.target.textContent = packets[idx].name; 
            }
           }).on('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); e.target.blur(); }}); // Enterキーで編集終了
        } else { // 既存のパケットdivがある場合 (forceFullRenderではない)
           packetDiv.find(`h6[data-idx="${packetIndex}"]`).text(packetData.name); // 名前のみ更新
        }
        
        // パケット内のドロップゾーン要素を取得
        const dropzoneElement = packetDiv.find(`.dropzone[data-idx="${packetIndex}"]`)[0];
        if (Sortable.get(dropzoneElement)) { Sortable.get(dropzoneElement).destroy(); } // SortableJSを一旦破棄
        
        // ドロップゾーンにSortableJSを再適用
        Sortable.create(dropzoneElement, { 
            group: 'shared', // 'shared'グループ (商品リストや他のパケットと連携)
            multiDrag: true, 
            selectedClass: 'selected', 
            animation: 150, 
            onEnd: handleSortableEndEvent // ドラッグ終了時の処理
        });
        
        // パケット内のアイテムをレンダリング (packets[packetIndex].items を元に)
        $(dropzoneElement).empty(); // ドロップゾーンの中身を一旦クリア
        (packetData.items || []).forEach(item => { // アイテムがあれば表示
            $(dropzoneElement).append(
                 // 各アイテムの情報をdata-*属性として埋め込み
                 `<div class="item" 
                      data-id="${item.id}"
                      data-source-file-name="${item.sourceFileName || ''}" 
                      data-name="${item.name || ''}"
                      data-qty="${item.qty}" 
                      data-price="${item.price}" 
                      data-slip-date="${item.slipDate || ''}" 
                      // ... (他のdata属性も同様)
                 >${item.name} (${item.qty})</div>`
            );
        });
      });
      // forceFullRenderでない場合、packets配列に存在しなくなった古いパケットdivをDOMから削除
      if (!forceFullRender) {
        container.find('.packet').each(function() {
            const currentPacketIdx = parseInt($(this).data('packet-idx'));
            if (currentPacketIdx >= packets.length) { // packets配列の長さを超えるインデックスのパケットは削除対象
                if (Sortable.get($(this).find('.dropzone')[0])) { 
                    Sortable.get($(this).find('.dropzone')[0]).destroy(); 
                }
                $(this).remove();
            }
        });
      }
      updateSums(); // 全パケットの合計金額を更新
    }
```

*   **目的**: ステップ2の右側にあるパケット群の表示を、グローバル変数 `packets` の内容に基づいて更新し、各パケットのドロップゾーンにSortableJSを適用します。
*   **引数**:
    *   `forceFullRender` (boolean, optional, default: `false`): `true` の場合、既存のパケットDOMを全て削除してから再描画します。`false` の場合、既存のパケットDOMをできるだけ再利用し、追加・削除されたパケットのみを処理しようとします。
*   **処理**:
    1.  パケットを表示するコンテナDOM要素 (`id="packets"`) を取得します。
    2.  `forceFullRender` が `true` の場合:
        *   コンテナ内の全ての `.dropzone` 要素からSortableJSインスタンスを破棄します。
        *   コンテナの中身 (`container.empty()`) を全て削除します。
    3.  グローバル変数 `packets` 配列の各パケットオブジェクト (`packetData`) についてループ処理します。`packetIndex` は配列内でのインデックスです。
        *   現在の `packetIndex` に対応するパケットのDOM要素 (`.packet[data-packet-idx="${packetIndex}"]`) が既に存在するか確認します。
        *   存在しない場合、または `forceFullRender` が `true` の場合:
            *   新しいパケットのHTML (`<div>` 要素、クラス名 `packet`) を生成します。このdivには `data-packet-idx` 属性でインデックスを保持します。
            *   内部には、編集可能な `<h6>` (パケット名)、アイテムをドロップする `.dropzone`、合計金額を表示する `.sum` を含みます。
            *   生成したパケットdivをコンテナに追加します。
            *   パケット名の `<h6>` 要素にイベントリスナーを設定します:
                *   `blur` (フォーカスが外れた時): 編集されたテキストを取得し、`packets[idx].name` を更新します。空欄にされた場合は元の名前に戻します。
                *   `keydown` (キー入力時): Enterキーが押されたら編集を終了（`blur`をトリガー）します。
        *   既存のパケットdivが存在し、`forceFullRender` でない場合は、パケット名 (`<h6>` のテキスト) のみ `packetData.name` の値で更新します。
        *   各パケットの `.dropzone` 要素を取得し、SortableJSインスタンスが適用されていれば一旦破棄し、新しく適用します。設定は `renderAllocationList` のものと同様で、`group: 'shared'` により商品リストや他のパケットとアイテムをやり取りできます。`onEnd: handleSortableEndEvent` でドラッグ終了時のデータ更新を処理します。
        *   **パケット内アイテムのレンダリング**:
            *   当該パケットの `.dropzone` の中身を一旦空にします。
            *   `packetData.items` (そのパケットが保持する商品アイテムの配列) をループし、各アイテムに対応する `div.item` 要素を生成し、ドロップゾーンに追加します。この `div.item` も `renderAllocationList` で生成されるものと同様に、`data-*` 属性に商品情報を持ちます。
    4.  `forceFullRender` でない場合、DOM上には存在するが現在の `packets` 配列にはもう存在しないパケット（例えば、パケットが削除された場合）をDOMから削除します。
    5.  `updateSums()`: 全てのパケットの合計金額表示を更新します（詳細は後述）。

**5.5. `handleSortableEndEvent(evt)`**

```javascript
    function handleSortableEndEvent(evt) {
        const itemEl = evt.item; // ドラッグされたDOM要素
        const itemId = $(itemEl).data('id'); // DOM要素のdata-id属性からアイテムのユニークIDを取得
        let movedItemData; // 移動対象のアイテムのデータオブジェクトを格納する変数

        // アイテムの移動元リストに応じて、対応するJavaScript配列からアイテムデータを検索・削除
        if (evt.from.id === 'allocation-list') { // 商品リストから移動した場合
            const itemIndex = allocationItems.findIndex(it => it.id === itemId); // allocationItems内でIDが一致するアイテムを探す
            if (itemIndex > -1) { // 見つかった場合
                movedItemData = allocationItems.splice(itemIndex, 1)[0]; // allocationItemsから削除し、削除されたアイテムデータを取得
            }
        } else { // 他のパケットのドロップゾーンから移動した場合
            const fromPacketIndex = $(evt.from).data('idx'); // 移動元のパケットインデックスを取得
            if (packets[fromPacketIndex] && packets[fromPacketIndex].items) { // 対応するパケットとアイテムリストが存在すれば
                const itemIndex = packets[fromPacketIndex].items.findIndex(it => it.id === itemId); // パケットのitems内でIDが一致するアイテムを探す
                if (itemIndex > -1) { // 見つかった場合
                    movedItemData = packets[fromPacketIndex].items.splice(itemIndex, 1)[0]; // パケットのitemsから削除し、アイテムデータを取得
                }
            }
        }

        // アイテムの移動先リストに応じて、対応するJavaScript配列にアイテムデータを追加
        if (movedItemData) { // movedItemDataが取得できていれば (つまり元の場所から正しく削除されていれば)
            if (evt.to.id === 'allocation-list') { // 商品リストに移動した場合
                // DOM上での新しい位置を取得し、allocationItems配列の同じ位置にアイテムデータを挿入
                const newDomIndex = Array.from(evt.to.children).indexOf(itemEl);
                allocationItems.splice(newDomIndex, 0, movedItemData);
            } else { // いずれかのパケットのドロップゾーンに移動した場合
                const toPacketIndex = $(evt.to).data('idx'); // 移動先のパケットインデックスを取得
                if (packets[toPacketIndex]) { // 対応するパケットが存在すれば
                    if (!packets[toPacketIndex].items) packets[toPacketIndex].items = []; // items配列がなければ作成
                    // DOM上での新しい位置を取得し、パケットのitems配列の同じ位置にアイテムデータを挿入
                    const newDomIndex = Array.from(evt.to.children).indexOf(itemEl);
                    packets[toPacketIndex].items.splice(newDomIndex, 0, movedItemData);
                }
            }
        } else {
            // console.warn("Could not find movedItemData for item ID:", itemId, "from:", evt.from.id); // アイテムデータが見つからなかった場合 (デバッグ用)
        }
        updateSums(); // 全パケットの合計金額表示を更新
    }
```

*   **目的**: SortableJSによるドラッグ＆ドロップ操作が完了したときに呼び出され、アイテムの移動をJavaScriptのデータ配列（`allocationItems` と `packets[...].items`）に反映させます。**これが商品分配の挙動の核心部分です。**
*   **引数**:
    *   `evt`: SortableJSから渡されるイベントオブジェクト。以下の情報を含みます。
        *   `evt.item`: ドラッグされたDOM要素。
        *   `evt.from`: 移動元のリストのDOM要素。
        *   `evt.to`: 移動先のリストのDOM要素。
*   **処理**:
    1.  ドラッグされたDOM要素 (`itemEl`) と、その `data-id` 属性からアイテムのユニークID (`itemId`) を取得します。
    2.  `movedItemData` 変数を初期化します。ここに、移動するアイテムの完全なデータオブジェクトを格納します。
    3.  **移動元からの削除**:
        *   `evt.from.id` をチェックし、アイテムが商品リスト (`allocation-list`) から移動されたのか、それとも他のパケットのドロップゾーンから移動されたのかを判断します。
        *   商品リストからの場合: `allocationItems` 配列内で `itemId` に一致するアイテムを `findIndex` で探し、見つかれば `splice` で削除します。削除されたアイテム（オブジェクト）は `movedItemData` に格納されます。
        *   パケットからの場合: `$(evt.from).data('idx')` で移動元のパケットのインデックスを取得し、`packets[fromPacketIndex].items` 配列内で同様にアイテムを探して削除し、`movedItemData` に格納します。
    4.  **移動先への追加**:
        *   `movedItemData` が正しく取得できた場合（つまり、元の場所からアイテムが見つかり削除された場合）に処理を続けます。
        *   `evt.to.id` をチェックし、アイテムが商品リスト (`allocation-list`) に移動されたのか、それともいずれかのパケットのドロップゾーンに移動されたのかを判断します。
        *   商品リストへの場合:
            *   `Array.from(evt.to.children).indexOf(itemEl)`: DOM上でアイテムがドロップされた位置（インデックス）を取得します。
            *   `allocationItems.splice(newDomIndex, 0, movedItemData)`: `allocationItems` 配列の、DOMと同じ位置に `movedItemData` を挿入します。
        *   パケットへの場合:
            *   `$(evt.to).data('idx')` で移動先のパケットのインデックスを取得します。
            *   対応する `packets[toPacketIndex].items` 配列がなければ初期化します。
            *   DOM上でのドロップ位置を取得し、そのパケットの `items` 配列の同じ位置に `movedItemData` を挿入します。
    5.  `updateSums()`: 全てのパケットの合計金額表示を更新します。

**5.6. `updateSums()`**

```javascript
    function updateSums() {
      $('.packet').each(function(idx) { // 画面上の各パケットDOM要素をループ
        let total = 0; 
        const packetIndex = $(this).data('packet-idx'); // パケットのインデックスを取得
        
        // 対応するpackets配列内のアイテムリストから合計金額を計算
        if (packets[packetIndex] && packets[packetIndex].items) {
            packets[packetIndex].items.forEach(item => {
                total += (parseFloat(item.qty) || 0) * (parseFloat(item.price) || 0);
            });
        }
        // 計算結果をパケットDOM内の .sum 要素に表示 (数値はtoLocaleStringで整形)
        $(this).find('.sum').text('合計: ' + total.toLocaleString() + ' 円');
      });
    }
```

*   **目的**: ステップ2の各パケットの下部に表示される合計金額を計算し、画面を更新します。
*   **処理**:
    1.  画面に表示されている各 `.packet` DOM要素についてループ処理します。
    2.  各パケットDOM要素の `data-packet-idx` 属性から、そのパケットのインデックス (`packetIndex`) を取得します。
    3.  `packets[packetIndex].items` (対応するグローバル `packets` 配列内のアイテムリスト) を参照します。
        *   このアイテムリストが存在し、アイテムが含まれていれば、各アイテムの `qty` (数量) と `price` (単価) を掛け合わせて合計金額 (`total`) を計算します。数量や単価が数値でない場合は0として扱います。
    4.  計算された `total` を、`toLocaleString()` で3桁区切りの文字列に変換し、「合計: XXX 円」という形式で、現在のパケットDOM内の `.sum` 要素のテキストとして設定します。

---

これで、提供されたコードの主要な部分の解説は以上です。このアプリケーションは、複数のライブラリを組み合わせ、多くのイベント処理とDOM操作を行って、複雑なワークフローを実現しています。特にSortableJSと連携したデータ配列の管理 (`handleSortableEndEvent`) が、ドラッグ＆ドロップによる商品配分機能の要となっています。
